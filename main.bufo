import "prelude.bufo";
import "libc.bufo";

module raylib {
    @os(LINUX) config {
        static: "libraylib.a",
        dynamic: "raylib.lib",
        libpath: "./raylib/lib",
    }
    @os(WINDOWS) config {
        static: "raylib.lib",
        dynamic: "raylib.dll",
        libpath: "./raylib/lib",
        static: "OpenGL32.lib",
        static: "msvcrt.lib",
        static: "Gdi32.lib",
        static: "WinMM.lib",
        static: "kernel32.lib",
        static: "shell32.lib",
        static: "User32.lib",
        linker: "/NODEFAULTLIB:libcmt",
    }
    @extern("InitWindow") func InitWindow(width: i32, height: i32, title: &char);
    @extern("CloseWindow") func CloseWindow();
    @extern("InitAudioDevice") func InitAudioDevice();
    @extern("CloseAudioDevice") func CloseAudioDevice();
    @extern("WindowShouldClose") func WindowShouldClose() -> bool;
    @extern("BeginDrawing") func BeginDrawing();
    @extern("EndDrawing") func EndDrawing();
    @extern("ClearBackground") func ClearBackground(c: Color);
    @extern("DrawRectangleV") func DrawRectangleV(pos: Vector2, size: Vector2, col: Color);
    @extern("ColorFromHSV") func ColorFromHSV(h: f32, s: f32, v: f32) -> Color;
    @extern("GetColor") func GetColor(val: u32) -> Color;
    @extern("LoadImageFromScreen") func LoadImageFromScreen() -> Image;
    @extern("ExportImage") func ExportImage(i: Image, name: &char) -> bool;
    @extern("PlaySound") func PlaySound(sound: Sound);
    @extern("LoadSound") func LoadSound(fileName: &char) -> Sound;
    @extern("IsSoundValid") func IsSoundValid(sound: Sound) -> bool;
    @extern("LoadWave") func LoadWave(fileName: &char) -> Wave;
    @extern("LoadSoundFromWave") func LoadSoundFromWave(wave: Wave) -> Sound;
    @extern("SetSoundVolume") func SetSoundVolume(sound: Sound, volume: f32);
    @extern("GetTime") func GetTime() -> f64;
    @extern("SetTargetFPS") func SetTargetFPS(fps: i32);
    @extern("GetScreenWidth") func GetScreenWidth() -> i32;
    @extern("GetScreenHeight") func GetScreenHeight() -> i32;
    @extern("IsKeyPressed") func IsKeyPressed(key: i32) -> bool;
    @extern("IsKeyDown") func IsKeyDown(key: i32) ->bool;
    @extern("GetRandomValue") func GetRandomValue(min: i32, max: i32) ->i32 ;
    @extern("DrawRectangleRec") func DrawRectangleRec(r: Rectangle, c: Color);
    @extern("CheckCollisionRecs") func CheckCollisionRecs(r1: Rectangle, r2: Rectangle) -> bool;
    @extern("LoadImage") func LoadImage(name: &char) -> Image;
    @extern("UnloadImage") func UnloadImage(img: Image);
    @extern("ImageRotateCCW") func ImageRotateCCW(image: &Image);
    @extern("ImageResize") func ImageResize(image: &Image, w: i32, h:i32);
    @extern("ImageDrawRectangleV") func ImageDrawRectangleV(dst: &Image, pos: Vector2, size: Vector2, c: Color);
    @extern("LoadTextureFromImage") func LoadTextureFromImage(img: Image) -> Texture;
    @extern("DrawTextureV") func DrawTextureV(tex: Texture, pos: Vector2, c: Color);

    struct Texture {
        id: usize;
        width: i32;
        height: i32;
        mipmaps: i32;
        format: i32;
    }
    struct Color {
        r: u8;
        g: u8;
        b: u8;
        a: u8;
    }

    struct Image {
        data: Any;
        width: i32;
        height: i32;
        mipmaps: i32;
        format: i32;
    }

    struct AudioStream {
        buffer: Any;
        processor: Any;

        sampleRate: u32;
        sampleSize: u32;
        channels: u32;
    }

    struct Sound {
        stream: AudioStream;
        frameCount: u32;
    }

    struct Wave {
        frameCount: u32;
        sampleRate: u32;
        sampleSize: u32;
        channels: u32;
        data: Any;
    }

    struct Vector2 {
        x: f32;
        y: f32;
    }


    struct Rectangle {
        x: f32;
        y: f32;
        width: f32;
        height: f32;
    }
}

func generate_rect(row: i32, col: i32) -> [raylib::Rectangle; 12] {
    let rect:[raylib::Rectangle; 12] = blank;
    let size  = raylib::Vector2 { x: 50, y: 40 };

    let rate_x: i32 = 100;
    let rate_y: i32 = 100;

    let total_width: i32 = (col - 1) * rate_x + size.x as i32;

    let px: i32 = (raylib::GetScreenWidth() - total_width) / 2;
    let py: i32 = 20;

    let pos = raylib::Vector2 {
       x: px as f32,
       y: py as f32
    };

    for(let i: i32 = 0; i < row; i = i + 1) {
        for(let j: i32 = 0; j < col; j = j + 1) {
            rect[(i * col + j) as usize] = raylib::Rectangle {
                x: pos.x,
                y: pos.y ,
                width: size.x,
                height: size.y
            };
            pos.x = pos.x + rate_x as f32;
        }

        pos.y = pos.y + rate_y as f32;
        pos.x = px as f32;
    }

    return rect;
}

struct Bullet {
    size: raylib::Vector2;
    pos: raylib::Vector2;
    vel: raylib::Vector2;
    active: bool;
    speed: f32;
}

func main(argc: i32, argv: &&char) -> i32 {
    raylib::InitWindow(900, 600, "bufo game");
    raylib::SetTargetFPS(60);

    let size  = raylib::Vector2 { x: 50, y: 50 };
    let img = raylib::LoadImage("./assets/img/character.png");
    raylib::ImageResize(&img, size.x as i32, size.y as i32);
    raylib::ImageRotateCCW(&img);
    let texture = raylib::LoadTextureFromImage(img);
    raylib::UnloadImage(img);

    let rate: f32 = 20;

    let bg = raylib::GetColor(0x181818FF);
    let red = raylib::GetColor(0xFF0000FF);
    let green = raylib::GetColor(0x00FF00FF);
    let white = raylib::GetColor(0xFFFFFFFF);

    let pos   = raylib::Vector2 {
        x: (raylib::GetScreenWidth() as f32 - size.x) / 2  ,
        y: raylib::GetScreenHeight() as f32 - 50 - size.y
    };

    let row: i32 = 3;
    let col: i32 = 4;

    let rect = generate_rect(row, col);
    let rect_active: [bool; 12] = [true, true, true, true, true, true, true, true, true, true, true, true];

    let bullet = Bullet {
        pos:  raylib::Vector2 { x: pos.x / 2,  y: pos.y },
        size: raylib::Vector2 { x: size.x / 2, y: size.y / 2 },
        vel:  raylib::Vector2 { x: 5,  y: -5 },
        active: false,
        speed: 10
    };

    while (!raylib::WindowShouldClose()) {
        if (raylib::IsKeyDown('A' as i32) || raylib::IsKeyDown(263)) {
            if (pos.x - rate > 0 as f32) {
                pos.x = pos.x - rate;
            }
        }
        if (raylib::IsKeyDown('D' as i32) || raylib::IsKeyDown(262)) {
            if (pos.x + rate + size.x < raylib::GetScreenWidth() as f32) {
                pos.x = pos.x + rate;
            }
        }
        if (raylib::IsKeyPressed(32) && !bullet.active) {
            bullet.pos.x = pos.x + (size.x - bullet.size.x) / 2;
            bullet.pos.y = pos.y + - bullet.size.y;
            bullet.vel.x = 5;
            bullet.vel.y = -5;
            bullet.active = true;
        }
        if(bullet.active) {
            bullet.pos.x = bullet.pos.x + bullet.vel.x;
            bullet.pos.y = bullet.pos.y + bullet.vel.y;

            if (bullet.pos.x <= 0 as f32) {
                bullet.pos.x = 0;
                bullet.vel.x = -bullet.vel.x;
            }
            if (bullet.pos.x + bullet.size.x >= raylib::GetScreenWidth() as f32) {
                bullet.pos.x = raylib::GetScreenWidth() as f32 - bullet.size.x;
                bullet.vel.x = -bullet.vel.x;
            }
            if (bullet.pos.y <= 0 as f32) {
                bullet.pos.y = 0;
                bullet.vel.y = -bullet.vel.y;
            }
            if (bullet.pos.y > raylib::GetScreenHeight() as f32) {
                bullet.active = false;
            }
            let paddle_rect = raylib::Rectangle {
                x: pos.x, y: pos.y,
                width: size.x, height: size.y
            };
            let ball_rect = raylib::Rectangle {
                x: bullet.pos.x, y: bullet.pos.y,
                width: bullet.size.x, height: bullet.size.y
            };
            if (raylib::CheckCollisionRecs(ball_rect, paddle_rect)) {
                bullet.pos.y = pos.y - bullet.size.y;
                bullet.vel.y = -bullet.vel.y;
                let hit_offset: f32 = (bullet.pos.x + bullet.size.x / 2) - (pos.x + size.x / 2);
                bullet.vel.x = hit_offset / 10;
            }
            for (let i: usize = 0; i < rect.length; i = i + 1) {
                if (rect_active[i] && raylib::CheckCollisionRecs(ball_rect, rect[i])) {
                    rect_active[i] = false;
                    bullet.vel.y = -bullet.vel.y;
                }
            }
        }

        raylib::BeginDrawing();
        raylib::ClearBackground(bg);
        raylib::DrawTextureV(texture, pos, white);

        for (let i: usize = 0; i < rect.length; i = i + 1) {
            if (rect_active[i]) raylib::DrawRectangleRec(rect[i], green);
        }
        if (bullet.active) raylib::DrawRectangleV(bullet.pos, bullet.size, white);

        raylib::EndDrawing();
    }
    raylib::CloseWindow();
    return 0;
}
