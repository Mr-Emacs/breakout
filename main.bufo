import "prelude.bufo";
import "libc.bufo";
import "raylib.bufo";

struct Bullet {
    size: raylib::Vector2;
    pos: raylib::Vector2;
    vel: raylib::Vector2;
    active: bool;
    speed: f32;
}

func generate_rect(row: i32, col: i32) -> [raylib::Rectangle; 12] {
    let rect:[raylib::Rectangle; 12] = blank;
    let size  = raylib::Vector2 { x: 50, y: 40 };

    let rate_x: i32 = 100;
    let rate_y: i32 = 100;

    let total_width: i32 = (col - 1) * rate_x + size.x as i32;

    let px: i32 = (raylib::GetScreenWidth() - total_width) / 2;
    let py: i32 = 20;

    let pos = raylib::Vector2 {
       x: px as f32,
       y: py as f32
    };


    for(let i: i32 = 0; i < row; i = i + 1) {
        for(let j: i32 = 0; j < col; j = j + 1) {
            rect[(i * col + j) as usize] = raylib::Rectangle {
                x: pos.x,
                y: pos.y ,
                width: size.x,
                height: size.y
            };
            pos.x = pos.x + rate_x as f32;
        }

        pos.y = pos.y + rate_y as f32;
        pos.x = px as f32;
    }

    return rect;
}

func main(argc: i32, argv: &&char) -> i32 {
    raylib::InitWindow(900, 600, "bufo game");
    raylib::InitAudioDevice();
    raylib::SetTargetFPS(60);

    // TODO: Idk how to pass the enums I do not want to do a lookup table
    // let sound = raylib::LoadShader("./assets/shader/main.fs");
    let sound = raylib::LoadSound("./assets/sounds/fart.mp3");
    raylib::SetSoundVolume(sound, 10 as f32);

    if (!raylib::IsSoundValid(sound)) {
        C::printf("FART ABOBA");
    }

    let size  = raylib::Vector2 { x: 50, y: 50 };
    let img = raylib::LoadImage("./assets/img/character.png");
    raylib::ImageResize(&img, size.x as i32, size.y as i32);
    raylib::ImageRotateCCW(&img);
    let texture = raylib::LoadTextureFromImage(img);
    raylib::UnloadImage(img);

    let rate: f32 = 20;

    let bg    = raylib::GetColor(0x181818FF);
    let red   = raylib::GetColor(0xFF0000FF);
    let green = raylib::GetColor(0x00FF00FF);
    let white = raylib::GetColor(0xFFFFFFFF);

    let cam = raylib::Camera2D {
         offset: raylib::Vector2 { x: 0, y: 0},
         target: raylib::Vector2 { x: 0, y: 0},
         rotation: 0,
         zoom: 1
    };

    let pos = raylib::Vector2 {
        x: (raylib::GetScreenWidth() as f32 - size.x) / 2  ,
        y: raylib::GetScreenHeight() as f32 - 50 - size.y
    };

    let row: i32 = 3;
    let col: i32 = 4;

    let rect = generate_rect(row, col);

    let rect_active: [bool; 12] = blank;
    for(let i = 0 as usize; i < 12; i = i + 1) {
        rect_active[i] = true;
    }

    let bullet = Bullet {
        pos:  raylib::Vector2 { x: pos.x / 2,  y: pos.y },
        size: raylib::Vector2 { x: size.x / 2, y: size.y / 2 },
        vel:  raylib::Vector2 { x: 5,  y: -5 },
        active: false,
        speed: 10
    };

    while (!raylib::WindowShouldClose()) {
        if (raylib::IsKeyDown('A' as i32) || raylib::IsKeyDown(263)) {
            if (pos.x - rate > 0 as f32) {
                pos.x = pos.x - rate;
            }
        }
        if (raylib::IsKeyDown('D' as i32) || raylib::IsKeyDown(262)) {
            if (pos.x + rate + size.x < raylib::GetScreenWidth() as f32) {
                pos.x = pos.x + rate;
            }
        }
        if (raylib::IsKeyPressed(32) && !bullet.active) {
            bullet.pos.x = pos.x + (size.x - bullet.size.x) / 2;
            bullet.pos.y = pos.y + - bullet.size.y;
            bullet.vel.x = 5;
            bullet.vel.y = -5;
            bullet.active = true;
        }
        if(bullet.active) {
            bullet.pos.x = bullet.pos.x + bullet.vel.x;
            bullet.pos.y = bullet.pos.y + bullet.vel.y;

            if (bullet.pos.x <= 0 as f32) {
                bullet.pos.x = 0;
                bullet.vel.x = -bullet.vel.x;
            }
            if (bullet.pos.x + bullet.size.x >= raylib::GetScreenWidth() as f32) {
                bullet.pos.x = raylib::GetScreenWidth() as f32 - bullet.size.x;
                bullet.vel.x = -bullet.vel.x;
            }
            if (bullet.pos.y <= 0 as f32) {
                bullet.pos.y = 0;
                bullet.vel.y = -bullet.vel.y;
            }
            if (bullet.pos.y > raylib::GetScreenHeight() as f32) {
                bullet.active = false;
            }
            let paddle_rect = raylib::Rectangle {
                x: pos.x, y: pos.y,
                width: size.x, height: size.y
            };
            let ball_rect = raylib::Rectangle {
                x: bullet.pos.x, y: bullet.pos.y,
                width: bullet.size.x, height: bullet.size.y

            };
            if (raylib::CheckCollisionRecs(ball_rect, paddle_rect)) {
                bullet.pos.y = pos.y - bullet.size.y;
                bullet.vel.y = -bullet.vel.y;
                let hit_offset: f32 = (bullet.pos.x + bullet.size.x / 2) - (pos.x + size.x / 2);
                bullet.vel.x = hit_offset / 10;
                raylib::PlaySound(sound);

            }
            for (let i: usize = 0; i < rect.length; i = i + 1) {
                if (rect_active[i] && raylib::CheckCollisionRecs(ball_rect, rect[i])) {
                    rect_active[i] = false;
                    bullet.vel.y = -bullet.vel.y;
                }
            }
        }

        raylib::BeginMode2D(cam);
            raylib::BeginDrawing();
            raylib::ClearBackground(bg);
            raylib::DrawTextureV(texture, pos, white);

            for (let i: usize = 0; i < rect.length; i = i + 1) {
                if (rect_active[i]) raylib::DrawRectangleRec(rect[i], green);
            }
            if (bullet.active) raylib::DrawRectangleV(bullet.pos, bullet.size, white);

            raylib::EndMode2D();
        raylib::EndDrawing();

    }

    raylib::CloseAudioDevice();
    raylib::CloseWindow();
    return 0;
}
